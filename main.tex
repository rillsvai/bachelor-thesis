\documentclass[12pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[ukrainian]{babel}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{amsmath, amsfonts, amssymb} % Додано amssymb для додаткових математичних символів
\usepackage{amsthm} % Додано пакет amsthm для оформлення середовищ
\usepackage{fancyhdr}
\usepackage{cmap}
\usepackage{tikz}

\usepackage[a4paper, margin=2.5cm]{geometry}

% Налаштування стилю сторінок
\fancypagestyle{plain}{
  \fancyhf{}
  \fancyhead[L]{\thepage}
  \fancyhead[R]{Квас Кирил ПМп-43}
  \renewcommand{\headrulewidth}{1pt}
  \renewcommand{\footrulewidth}{0pt}
  \setlength{\headheight}{14.49998pt}
}

% Визначення стилів середовищ
\theoremstyle{definition}
\newtheorem{definition}{Визначення}[chapter]
\newtheorem{example}{Приклад}[chapter]

\theoremstyle{plain}
\newtheorem{theorem}{Теорема}[chapter]
\newtheorem{lemma}{Лема}[chapter]
\newtheorem{corollary}{Королярій}[chapter]

\setcounter{tocdepth}{2}

\begin{document}

% Титульна сторінка
\begin{titlepage}
    \begin{center}
        \large 
        \textbf{Міністерство освіти і науки України}\\
        \textbf{Львівський національний університет імені Івана Франка}\\
        \vspace{0.5cm}
        \textbf{Факультет прикладної математики та інформатики}\\
        \textbf{Кафедра прикладної математики}\\
        
        \vfill
        
        \Large 
        \textbf{Бакалаврська робота}\\
        \vspace{0.3cm}
        \normalsize 
        \textbf{на тему:}\\
        \vspace{0.3cm}
        \Large 
        \textbf{Ефективність класичних алгоритмів криптографії \\ на основі еліптичних кривих}\\
        
        \vfill
        
        \begin{flushright}
            \normalsize 
            Виконав студент групи ПМП-43:\\
            Квас Кирил Олегович\\
            спеціальність 113 — Прикладна математика\\
            \vspace{1cm}
            Науковий керівник:\\
            доцент, кандидат фізико-математичних наук\\
            Стягар Андрій Орестович \\
            \vspace{1cm}
            Рецензент:\\
            \vspace{0.5cm}
            \underline{\hspace{7cm}}
        \end{flushright}
        
        \vfill
        
        \normalsize 
        Львів — 2024
    \end{center}
\end{titlepage}

% Зміст
\tableofcontents

% Вступ
\chapter*{Вступ}
\addcontentsline{toc}{chapter}{Вступ}

У сучасному світі інформаційна безпека набуває все більшої значущості у зв’язку з постійним зростанням обсягів переданої та збереженої інформації. Захист даних від несанкціонованого доступу, зміни чи видалення є однією з ключових задач у сфері інформаційних технологій. Криптографія виступає як основний інструмент для забезпечення конфіденційності, цілісності та автентичності інформації.

\section{Історія криптографії}

Криптографія має давню історію, яка бере свій початок ще в давніх цивілізаціях. Від найпростіших методів шифрування до сучасних складних алгоритмів, криптографія розвивалась у відповідь на зростаючі потреби у безпеці інформації.

Перші спроби захисту інформації датуються часами Стародавнього Єгипту, де використовувалися прості символічні шифри для передачі секретних повідомлень. У середньовіччі арабські вчені, такі як Аль-Хорезмі, зробили значний внесок у розвиток криптографії, створюючи складніші шифри та методи їх розшифровки.

У 20 столітті криптографія отримала новий імпульс завдяки появі комп'ютерів та сучасних методів математичного аналізу. Під час Другої світової війни розвиток криптографії досягнув свого піку з розшифровкою німецьких шифрів "Енігма" Бертраном Расселом та іншими вченими. Ці події продемонстрували важливість криптографії для військових та державних потреб.

Після численних війн криптографія почала активно застосовуватись у цивільному секторі, особливо з розвитком електронної комунікації. Виникнення Інтернету та цифрових технологій підвищило потребу у надійних методах захисту інформації, що сприяло розвитку асиметричних криптографічних алгоритмів.

\section{Сучасні криптографічні алгоритми}

Класичні алгоритми криптографії, такі як RSA та алгоритми на основі дискретного логарифму, довгий час були основою для захисту інформаційних систем. RSA (Rivest–Shamir–Adleman) є одним із найпоширеніших асиметричних алгоритмів, що використовуються для шифрування та цифрових підписів. Його безпека базується на складності задачі факторизації великих простих чисел, що робить його стійким до більшості відомих криптографічних атак.

Проте з розвитком комп’ютерних технологій та зростанням вимог до ефективності криптографічних систем виникає необхідність у пошуку більш ефективних та безпечних методів. Одним із таких напрямків є криптографія на основі еліптичних кривих (Elliptic Curve Cryptography, ECC).

\section{Криптографія на основі еліптичних кривих}

Криптографія на основі еліптичних кривих дозволяє досягати високого рівня безпеки при використанні коротших ключів порівняно з класичними методами. Це сприяє зменшенню вимог до обчислювальних ресурсів та забезпечує більш ефективну реалізацію криптографічних протоколів, що є особливо важливим для обмежених ресурсів середовищ, таких як мобільні пристрої та вбудовані системи. 

Процес адаптації класичних алгоритмів асиметричної криптографії до варіацій на основі еліптичних кривих включає заміну основної математичної задачі з факторизації великих чисел на задачу дискретного логарифму на еліптичних кривих. Це дозволяє зменшити розмір ключів та підвищити ефективність обчислювальних операцій, необхідних для шифрування, дешифрування та створення цифрових підписів. Наприклад, у випадку RSA, де для забезпечення певного рівня безпеки використовуються ключі розміром 2048 біт, ECC може забезпечити аналогічний рівень безпеки з ключами розміром лише 256 біт. Це значно зменшує обсяг збережених даних та прискорює криптографічні операції, що є критично важливим для пристроїв з обмеженими ресурсами.

\section{Мета та завдання дослідження}

Метою цієї кваліфікаційної роботи є дослідження ефективності класичних алгоритмів криптографії на основі еліптичних кривих. Зокрема, буде проведено аналіз продуктивності певного класичного алгоритму та його варіації на основі еліптичних кривих, а також оцінено їх придатність для застосування у сучасних інформаційних системах.

Завданнями дослідження є:

\begin{itemize}
    \item Ознайомлення з основними принципами та теорією криптографії потрібної для даної кваліфікаційної роботи.
    \item Аналіз існуючих класичних криптографічних алгоритмів та їх варіацій, що використовують еліптичні криві.
    \item Проведення експериментального дослідження ефективності обраних алгоритмів.
    \item Порівняння отриманих результатів та формулювання висновків щодо їх практичної застосовності.
\end{itemize}

\section{Методологія дослідження}

Для досягнення поставленої мети та вирішення завдань дослідження будуть використані наступні методи:

\begin{itemize}
    \item \textbf{Теоретичний аналіз:} Вивчення наукової літератури, математичних основ та алгоритмічних структур класичних асиметричних алгоритмів та ECC.
    \item \textbf{Порівняльний аналіз:} Оцінка ключових характеристик обох типів алгоритмів, таких як розмір ключів, обчислювальна складність, рівень безпеки.
    \item \textbf{Експериментальні методи:} Реалізація обраних алгоритмів у програмному середовищі та проведення тестів для вимірювання продуктивності та аналізу безпеки.
    \item \textbf{Статистичний аналіз:} Обробка та інтерпретація отриманих даних з метою визначення тенденцій та формулювання висновків.
\end{itemize}

\section{Очікувані результати}

Очікується, що результати дослідження дозволять визначити переваги та недоліки класичних асиметричних алгоритмів у порівнянні з їх варіаціями на основі еліптичних кривих. Зокрема, передбачається, що ECC забезпечить більш ефективне використання обчислювальних ресурсів при збереженні високого рівня безпеки, що робить його привабливим для використання у сучасних інформаційних системах. Крім того, результати можуть бути використані для оптимізації криптографічних систем, що застосовуються у різних сферах, включаючи мобільні комунікації, Інтернет речей (IoT), фінансові транзакції та захист конфіденційних даних.

\chapter{Постановка задачі}

\section{Описова постановка}

Нам задано довільний класичний алгоритм асиметричної криптографії та його варіацію на основі еліптичних кривих. Метою даного дослідження є розгляд та пояснення процесу адаптації класичного алгоритму до версії на основі еліптичних кривих, а також проведення ретельного і детального аналізу їх ефективності, безпеки та практичної релевантності на даний момент.

Зокрема, буде проведено порівняння обраного класичного алгоритму (Алгоритм 1) з його еквівалентною варіацією на основі еліптичних кривих (ECC) (Алгоритм 2). Аналіз охоплюватиме наступні аспекти:
\begin{itemize}
    \item \textbf{Процес адаптації:} Вивчення змін у математичній основі та алгоритмічній структурі при переході від Алгоритму 1 до Алгоритму 2.
    \item \textbf{Ефективність:} Оцінка швидкості виконання операцій шифрування та дешифрування, використання обчислювальних ресурсів та розміру ключів.
    \item \textbf{Безпека:} Аналіз стійкості алгоритмів до сучасних криптографічних атак, включаючи класичні та квантові атаки.
    \item \textbf{Практична релевантність:} Визначення придатності алгоритмів для застосування у різних умовах, таких як мобільні пристрої, вбудовані системи та великі інформаційні мережі.
\end{itemize}

Дослідження спрямоване на визначення переваг та недоліків класичних асиметричних алгоритмів у порівнянні з їх варіаціями на основі еліптичних кривих, а також надання рекомендацій щодо вибору оптимальних криптографічних методів для різних сфер застосування.

\section{Математична модель}

Рисунок \ref{fig:basic_protocol_classical} і \ref{fig:basic_protocol_ecc} демонструє процес обміну зашифрованими повідомленнями між двома сторонами: відправником (Алісою) та отримувачем (Бобом) для класичного і аналогу на основі еліптичних кривих відповідно.

\begin{figure}[htbp]
\begin{center}
\begin{tikzpicture}

% Alice and Bob nodes
\node at (-2, 0) {\textbf{Аліса}};
\node at (8, 0) {\textbf{Боб}};

% Encryption and decryption
\node at (-0.9, -1) {$y = e_{k_{\text{pub}}^{(1)}}(x)$};
\node at (6.9, -1) {$x = d_{k_{\text{pr}}^{(1)}}(y)$};

% Key pair generation
\node at (7.5, 1) {$(k_{\text{pub}}^{(1)}, k_{\text{pr}}^{(1)}) = k^{(1)}$};

% Arrows and labels
\draw[<-] (0.5, 1) -- (5.5, 1) node[midway, above] {$k_{\text{pub}}^{(1)}$};
\draw[->] (0.5, -1) -- (5.5, -1) node[midway, below] {$y^{(1)}$};

\end{tikzpicture}
\caption{Базовий протокол асиметричного шифрування на основі класичного алгоритму.}
\label{fig:basic_protocol_classical}
\end{center}
\end{figure}

\begin{figure}[htbp]
\begin{center}
\begin{tikzpicture}

% Alice and Bob nodes
\node at (-2, 0) {\textbf{Аліса}};
\node at (8, 0) {\textbf{Боб}};

% Encryption and decryption
\node at (-0.9, -1) {$y = e_{k_{\text{pub}}^{(2)}}(x)$};
\node at (6.9, -1) {$x = d_{k_{\text{pr}}^{(2)}}(y)$};

% Key pair generation
\node at (7.5, 1) {$(k_{\text{pub}}^{(2)}, k_{\text{pr}}^{(2)}) = k^{(2)}$};

% Arrows and labels
\draw[<-] (0.5, 1) -- (5.5, 1) node[midway, above] {$k_{\text{pub}}^{(2)}$};
\draw[->] (0.5, -1) -- (5.5, -1) node[midway, below] {$y^{(2)}$};

\end{tikzpicture}
\caption{Базовий протокол асиметричного шифрування на основі ECC.}
\label{fig:basic_protocol_ecc}
\end{center}
\end{figure}

\begin{itemize}
    \item $k_{\text{pub}}^{(1)}$, $k_{\text{pub}}^{(2)}$: публічний ключ для класичного алгоритму та ECC відповідно.
    \item $k_{\text{pr}}^{(1)}$, $k_{\text{pr}}^{(2)}$: приватний ключ для класичного алгоритму та ECC відповідно.
    \item $k^{(1)}$, $k^{(2)}$: пара ключів (публічний і приватний) для класичного алгоритму та ECC відповідно.
    \item $e_{k_{\text{pub}}^{(1)}}$, $e_{k_{\text{pub}}^{(2)}}$: функція шифрування з використанням публічного ключа.
    \item $d_{k_{\text{pr}}^{(1)}}$, $d_{k_{\text{pr}}^{(2)}}$: функція дешифрування з використанням приватного ключа.
    \item $x$: вихідне повідомлення, яке потрібно зашифрувати.
    \item $y^{(1)}, y^{(2)}$: зашифроване повідомлення з використанням класичного алгоритму та ECC відповідно.
\end{itemize}

\chapter{Проблема дискретного логарифму}

\section{Огляд головних криптографічних схем}

Сучасна криптографія спирається на три основні сімейства алгоритмів відкритого ключа, які мають практичну значущість і базуються на різних математичних проблемах. Кожне з цих сімейств забезпечує основні криптографічні функції, такі як встановлення ключів, цифрові підписи для нерепудійованості та шифрування даних. У цьому розділі наведено короткий огляд цих трьох сімейств, спираючись на матеріали книги Крістофа Паара.

\subsection{Схеми на основі факторизації цілих чисел}

Схеми цього сімейства ґрунтуються на складності задачі факторизації великих цілих чисел. Найвідомішим представником цього сімейства є алгоритм RSA, запропонований у 1977 році. RSA широко використовується для шифрування, цифрових підписів та встановлення ключів. Ефективність RSA залежить від обчислювальної складності розкладу великих чисел на прості множники. При виборі належних параметрів, таких як довжина ключа, алгоритм забезпечує високий рівень безпеки.

\subsection{Схеми на основі дискретного логарифму}

Алгоритми цього сімейства базуються на задачі дискретного логарифму в скінченних полях. До найвідоміших представників належать:
\begin{itemize}
    \item Протокол обміну ключами Діффі–Геллмана (Diffie–Hellman Key Exchange),
    \item Шифрування Ель-Гамаля (ElGamal Encryption),
    \item Алгоритм цифрового підпису (Digital Signature Algorithm, DSA).
\end{itemize}

Ці алгоритми були запропоновані в середині 1970-х років і залишаються надійними за умови правильного вибору параметрів. В основі їх безпеки лежить складність обчислення дискретного логарифму — задачі, для якої не існує відомих ефективних алгоритмів розв’язання.

\subsection{Схеми на основі еліптичних кривих}

Ця група є узагальненням схем на основі дискретного логарифму. Алгоритми на основі еліптичних кривих (Elliptic Curve Cryptography, ECC) були запропоновані в середині 1980-х років і мають перевагу у зменшенні розмірів ключів без втрати рівня безпеки. Найвідоміші приклади включають:
\begin{itemize}
    \item Обмін ключами за допомогою еліптичних кривих (Elliptic Curve Diffie–Hellman, ECDH),
    \item Алгоритм цифрового підпису на основі еліптичних кривих (Elliptic Curve Digital Signature Algorithm, ECDSA).
\end{itemize}

Схеми ECC використовують коротші ключі порівняно з класичними алгоритмами, такими як RSA, забезпечуючи такий самий рівень криптографічної безпеки. Це робить ECC привабливими для середовищ з обмеженими ресурсами, наприклад, мобільних пристроїв або вбудованих систем.

\subsection{Інші схеми відкритого ключа}

Окрім трьох основних сімейств, існують також інші схеми, такі як:
\begin{itemize}
    \item Мультиваріативні квадратичні схеми (Multivariate Quadratic, MQ),
    \item Схеми на основі ґраток (Lattice-based schemes),
    \item Криптосистеми McEliece.
\end{itemize}

Проте ці схеми часто мають недостатню криптографічну зрілість або погані характеристики реалізації, наприклад, надмірно великі ключі. Інші схеми, наприклад, криптосистеми на основі гіпереліптичних кривих, є як ефективними, так і безпечними, але поки що не набули широкого розповсюдження. Для більшості застосувань рекомендовано використовувати схеми з трьох основних сімейств.

Таким чином, головними сімействами алгоритмів відкритого ключа, які забезпечують надійний захист і практичність, є схеми на основі факторизації цілих чисел, дискретного логарифму та еліптичних кривих.

\section{Алгебраїчні структури в контексті дискретного логарифму}

Для розуміння задачі дискретного логарифму важливо ввести базові алгебраїчні структури, які використовуються в криптографії. До них належать групи, циклічні групи, а також їхні підгрупи.

\subsection{Групи}

\begin{definition}[Група]
Групою \( G \) називається множина елементів разом з операцією \( \circ \), яка комбінує два елементи \( G \). Група задовольняє наступні властивості:
\begin{enumerate}
    \item \textbf{Замкненість:} Для всіх \( a, b \in G \) результат операції \( a \circ b \) також належить \( G \).
    \item \textbf{Асоціативність:} \( a \circ (b \circ c) = (a \circ b) \circ c \) для всіх \( a, b, c \in G \).
    \item \textbf{Нейтральний елемент:} Існує елемент \( e \in G \), такий що \( a \circ e = e \circ a = a \) для всіх \( a \in G \).
    \item \textbf{Обернений елемент:} Для кожного \( a \in G \) існує \( a^{-1} \in G \), такий що \( a \circ a^{-1} = a^{-1} \circ a = e \).
\end{enumerate}
Якщо додатково виконується \textbf{комутативність} (\( a \circ b = b \circ a \)), така група називається \textbf{абелевою}.
\end{definition}

\begin{example}
\begin{itemize}
    \item Множина цілих чисел \( \mathbb{Z} \) з операцією додавання утворює абелеву групу, де \( 0 \) є нейтральним елементом, а \( -a \) є оберненим до \( a \).
    \item Множина \( \mathbb{Z}^*_n \) (всі числа, менші за \( n \) і взаємно прості з \( n \)) з операцією множення за модулем \( n \) утворює абелеву групу, якщо \( n > 1 \).
\end{itemize}
\end{example}

\subsection{Скінченні групи}

\begin{definition}[Скінченна група]
Група \( (G, \circ) \) називається \textbf{скінченною}, якщо вона містить скінченну кількість елементів. Кількість елементів у групі називається її \textbf{порядком} і позначається \( |G| \).
\end{definition}

\begin{example}
\begin{itemize}
    \item Множина \( \mathbb{Z}_n \) з операцією додавання за модулем \( n \) має порядок \( |G| = n \).
    \item Для множини \( \mathbb{Z}^*_9 = \{1, 2, 4, 5, 7, 8\} \) порядок дорівнює \( |\mathbb{Z}^*_9| = 6 \).
\end{itemize}
\end{example}

\subsection{Циклічні групи}

\begin{definition}[Порядок елемента]
Порядком \( \text{ord}(a) \) елемента \( a \) групи \( (G, \circ) \) називається найменше додатне ціле число \( k \), таке що \( a^k = e \), де \( e \) — нейтральний елемент групи.
\end{definition}

\begin{example}
Визначимо порядок елемента \( a = 3 \) у групі \( \mathbb{Z}^*_{11} \):
\[
\begin{aligned}
a^1 & = 3 \\
a^2 & = 3 \cdot 3 = 9 \mod 11 \\
a^3 & = 9 \cdot 3 = 27 \equiv 5 \mod 11 \\
a^4 & = 5 \cdot 3 = 15 \equiv 4 \mod 11 \\
a^5 & = 4 \cdot 3 = 12 \equiv 1 \mod 11
\end{aligned}
\]
Отже, \( \text{ord}(3) = 5 \).
\end{example}

\begin{definition}[Циклічна група]
Група \( G \) називається \textbf{циклічною}, якщо існує елемент \( \alpha \in G \) з максимальним порядком \( \text{ord}(\alpha) = |G| \). Такий елемент \( \alpha \) називається \textbf{генератором} або \textbf{примітивним елементом}, оскільки кожен елемент \( g \in G \) можна записати як \( g = \alpha^k \) для деякого \( k \).
\end{definition}

\begin{example}
Група \( \mathbb{Z}^*_{11} = \{1, 2, 3, 4, 5, 6, 7, 8, 9, 10\} \) є циклічною. Елемент \( 2 \) є генератором, оскільки степені \( 2^i \mod 11 \) проходять усі елементи групи:
\[
\{2, 4, 8, 5, 10, 9, 7, 3, 6, 1\}
\]
Отже, \( \text{ord}(2) = 10 = |\mathbb{Z}^*_{11}| \).
\end{example}

\subsection{Теореми про циклічні групи}

\begin{theorem}
Якщо \( |G| = n \), то порядок будь-якого елемента \( a \in G \) ділить \( n \).
\end{theorem}

\begin{theorem}
Якщо \( G \) є циклічною групою з порядком \( n \), то кількість генераторів у \( G \) дорівнює \( \varphi(n) \), де \( \varphi \) — функція Ейлера.
\end{theorem}

\begin{example}
Для групи \( \mathbb{Z}^*_{11} \) з порядком \( |G| = 10 \) кількість генераторів дорівнює \( \varphi(10) = 4 \). Ці генератори — елементи \( \{2, 6, 7, 8\} \).
\end{example}

\subsection{Підгрупи}

\begin{definition}[Підгрупа]
Підгрупою \( H \subset G \) називається підмножина \( H \), яка сама є групою щодо операції \( \circ \), визначеної в \( G \).
\end{definition}

\begin{theorem}[Циклічна підгрупа]
Нехай \( G \) є циклічною групою. Тоді кожен елемент \( a \in G \) з порядком \( \text{ord}(a) = s \) є генератором циклічної підгрупи з \( s \) елементами.
\end{theorem}

\begin{example}
Розглянемо групу \( \mathbb{Z}^*_{11} \). Елемент \( a = 3 \) має порядок \( \text{ord}(3) = 5 \), тому підгрупа, згенерована \( 3 \), містить елементи \( \{1, 3, 4, 5, 9\} \). Перевіримо це за допомогою таблиці множення:

\begin{table}[h!]
\centering
\begin{tabular}{c|ccccc}
$\times \mod 11$ & 1 & 3 & 4 & 5 & 9 \\
\hline
1 & 1 & 3 & 4 & 5 & 9 \\
3 & 3 & 9 & 1 & 4 & 5 \\
4 & 4 & 1 & 5 & 9 & 3 \\
5 & 5 & 4 & 9 & 3 & 1 \\
9 & 9 & 5 & 3 & 1 & 4 \\
\end{tabular}
\caption{Таблиця множення для підгрупи \( H = \{1, 3, 4, 5, 9\} \) у групі \( \mathbb{Z}^*_{11} \).}
\label{tab:multiplication_H}
\end{table}

Отже, \( H = \{1, 3, 4, 5, 9\} \) є підгрупою групи \( \mathbb{Z}^*_{11} \) з порядком \( |H| = 5 \).
\end{example}

\subsection{Теорема Лагранжа}

\begin{theorem}[Теорема Лагранжа]
Нехай \( H \) є підгрупою групи \( G \). Тоді порядок підгрупи \( |H| \) ділить порядок групи \( |G| \).
\end{theorem}

\begin{example}
Група \( \mathbb{Z}^*_{11} \) має порядок \( |G| = 10 \). Відповідно до теореми Лагранжа, можливі порядки підгруп: \( 1, 2, 5, 10 \). Виявляється, що підгрупи мають відповідні порядки:
\begin{itemize}
    \item \( H_1 = \{1\} \) з порядком \( 1 \),
    \item \( H_2 = \{1, 10\} \) з порядком \( 2 \),
    \item \( H_3 = \{1, 3, 4, 5, 9\} \) з порядком \( 5 \),
    \item \( H_4 = \mathbb{Z}^*_{11} \) з порядком \( 10 \).
\end{itemize}
\end{example}

\subsection{Циклічна підгрупа та Генератори}

\begin{theorem}
Нехай \( G \) є циклічною групою порядку \( n \), і нехай \( \alpha \) — її генератор. Тоді для кожного дільника \( k \) числа \( n \) існує рівно одна циклічна підгрупа \( H \) порядку \( k \), яка генерується елементом \( \beta = \alpha^{n/k} \). Підгрупа \( H \) складається з елементів \( \{1, \beta, \beta^2, \ldots, \beta^{k-1}\} \).
\end{theorem}

\begin{example}
Розглянемо групу \( \mathbb{Z}^*_{11} \) з порядком \( |G| = 10 \) і генератором \( \alpha = 8 \). Хочемо знайти генератор підгрупи порядку \( k = 2 \):
\[
\beta = \alpha^{10/2} = 8^5 \equiv 32768 \equiv 10 \mod 11.
\]
Перевіримо, що \( \beta = 10 \) генерує підгрупу \( H = \{1, 10\} \):
\[
\beta^1 \equiv 10 \mod 11, \quad \beta^2 \equiv 100 \equiv 1 \mod 11.
\]
Отже, \( H = \{1, 10\} \) є підгрупою порядку \( 2 \), згенерованою елементом \( 10 \).
\end{example}



\section{Дискретний логарифм}

\subsection{Формальне визначення дискретного логарифму}

Ми починаємо з дискретного логарифму в групі \( \mathbb{Z}^*_p \), де \( p \) — просте число.

\begin{definition}[Дискретний логарифм (DLP) в \( \mathbb{Z}^*_p \)]
Дано скінченну циклічну групу \( \mathbb{Z}^*_p \) порядку \( p - 1 \), примітивний елемент \( \alpha \in \mathbb{Z}^*_p \) та інший елемент \( \beta \in \mathbb{Z}^*_p \). DLP полягає у визначенні цілого числа \( 1 \leq x \leq p - 1 \), такого що:
\[
\alpha^x \equiv \beta \mod p
\]
Таке число \( x \) називається дискретним логарифмом \( \beta \) до основи \( \alpha \), і формально записується як:
\[
x = \log_\alpha \beta \mod p.
\]
Обчислення дискретних логарифмів за модулем простого числа є дуже складною задачею за умови достатньо великих параметрів. Оскільки експонентування \( \alpha^x \equiv \beta \mod p \) є обчислювально легким, це утворює односторонню функцію.
\end{definition}

\subsection{Приклади дискретного логарифму}

\begin{example}[Приклад 8.11]
Розглянемо дискретний логарифм у групі \( \mathbb{Z}^*_{47} \), де \( \alpha = 5 \) є примітивним елементом. Для \( \beta = 41 \) задача дискретного логарифму полягає у визначенні позитивного цілого числа \( x \), такого що
\[
5^x \equiv 41 \mod 47
\]
Навіть для таких малих чисел визначення \( x \) не є повністю простим завданням. Використовуючи метод перебору, тобто систематичне перевіряння всіх можливих значень \( x \), ми отримуємо розв'язок \( x = 15 \).
\end{example}

На практиці часто бажано мати DLP у групах з простим порядком, щоб уникнути атаки Погіля-Геллмана (див. секцію 8.3.3). Оскільки групи \( \mathbb{Z}^*_p \) мають порядок \( p - 1 \), який очевидно не є простим, зазвичай використовуються DLP у підгрупах \( \mathbb{Z}^*_p \) з простим порядком, а не сама група \( \mathbb{Z}^*_p \). Наведемо приклад.

\begin{example}[Приклад 8.12]
Розглянемо групу \( \mathbb{Z}^*_{47} \), яка має порядок 46. Підгрупи в \( \mathbb{Z}^*_{47} \) мають порядки 23, 2 та 1. \( \alpha = 2 \) є елементом підгрупи з 23 елементами, і оскільки 23 — просте число, \( \alpha \) є примітивним елементом у підгрупі. Можлива задача дискретного логарифму для \( \beta = 36 \) (який також належить підгрупі): знайти позитивне ціле число \( x \), \( 1 \leq x \leq 23 \), таке що
\[
2^x \equiv 36 \mod 47
\]
Використовуючи метод перебору, ми отримуємо розв'язок \( x = 17 \).
\end{example}

Особливість, що робить DLP особливо корисним у криптографії, полягає в тому, що він не обмежений множинною групою \( \mathbb{Z}^*_p \), де \( p \) — просте число, але може бути визначений у будь-яких циклічних групах. Це називається узагальненим дискретним логарифмом (GDLP) і може бути сформульовано наступним чином.

\begin{definition}[Узагальнений дискретний логарифм (GDLP)]
Дано скінченну циклічну групу \( G \) з операцією групи \( \circ \) та порядком \( n \). Розглядається примітивний елемент \( \alpha \in G \) та інший елемент \( \beta \in G \). Задача дискретного логарифму полягає у визначенні цілого числа \( x \), де \( 1 \leq x \leq n \), такого що:
\[
\beta = \alpha \circ \alpha \circ \ldots \circ \alpha = \alpha^x
\]
(повторення \( \alpha \) \( x \) разів).


Як і у випадку DLP у \( \mathbb{Z}^*_p \), таке число \( x \) обов'язково існує, оскільки \( \alpha \) є примітивним елементом, і таким чином кожен елемент групи \( G \) можна згенерувати шляхом повторного застосування операції групи до \( \alpha \).
\end{definition}

\subsection{Приклад узагальненого дискретного логарифму}

\begin{example}[Приклад 8.13]
Цього разу розглянемо адитивну групу цілих чисел за модулем простого числа. Наприклад, якщо оберемо просте число \( p = 11 \), група \( G = (\mathbb{Z}_{11}, +) \) є скінченною циклічною групою з примітивним елементом \( \alpha = 2 \). Ось як \( \alpha \) генерує групу:
\[
\begin{array}{c|ccccccccccc}
i & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 \\
\hline
i\alpha & 2 & 4 & 6 & 8 & 10 & 1 & 3 & 5 & 7 & 9 & 0 \\
\end{array}
\]
Спробуємо тепер вирішити DLP для елемента \( \beta = 3 \), тобто маємо обчислити ціле число \( 1 \leq x \leq 11 \), таке що
\[
x \cdot 2 = 2 + 2 + \ldots + 2 \equiv 3 \mod 11
\]
(повторення \( 2 \) \( x \) разів).

Щоб вирішити для \( x \), ми просто маємо інвертувати примітивний елемент \( \alpha \):
\[
x \equiv 2^{-1} \cdot 3 \mod 11
\]
Використовуючи, наприклад, розширений алгоритм Евкліда, можемо обчислити \( 2^{-1} \equiv 6 \mod 11 \), з чого дискретний логарифм слідує як:
\[
x \equiv 2^{-1} \cdot 3 \equiv 6 \cdot 3 \equiv 18 \equiv 7 \mod 11
\]
Дискретний логарифм можна перевірити, подивившись на невелику таблицю, наведений вище.
\end{example}

Ми можемо узагальнити цей трюк до будь-якої групи \( (\mathbb{Z}_n, +) \) для довільного \( n \) та елементів \( \alpha, \beta \in \mathbb{Z}_n \). Отже, ми робимо висновок, що узагальнений DLP є обчислювально легким у \( \mathbb{Z}_n \). Причина, чому DLP тут можна легко вирішити, полягає в тому, що ми маємо математичні операції, які не належать адитивній групі, а саме множення та інверсія.

\section{Безпека дискретного логарифму}

У цьому розділі розглядаються методи вирішення задач дискретного логарифму (DLP). Читачам, які цікавляться лише конструктивним використанням схем на основі DLP, можна пропустити цей розділ. Як ми бачили, безпека багатьох асиметричних примітивів базується на складності обчислення DLP у циклічних групах, тобто на обчисленні \( x \) для даних \( \alpha \) та \( \beta \) у групі \( G \) таких, що
\[
\beta = \alpha \circ \alpha \circ \ldots \circ \alpha = \alpha^x
\]
(повторення \( \alpha \) \( x \) разів)
дійсно. Ми все ще не знаємо точної складності обчислення дискретного логарифму \( x \) у будь-якій конкретній групі. Під цим ми маємо на увазі, що хоча відомі деякі атаки, невідомо, чи існують якісь кращі, потужніші алгоритми для вирішення DLP. Ця ситуація схожа на складність факторизації цілих чисел, яка є основою RSA. Ніхто не знає, який найкращий можливий метод факторизації. Для DLP існують цікаві загальні результати щодо її обчислювальної складності. У цьому розділі надається короткий огляд алгоритмів для обчислення дискретних логарифмів, які можна класифікувати на генеричні та негенеричні алгоритми, і які будуть розглянуті детальніше нижче.

\subsection{Генеричні алгоритми}

Генеричні алгоритми DLP — це методи, які використовують лише операцію групи і не використовують іншу алгебраїчну структуру групи. Оскільки вони не експлуатують спеціальні властивості групи, вони працюють у будь-якій циклічній групі. Генеричні алгоритми для задачі дискретного логарифму можна поділити на два класи. Перший клас включає алгоритми, час виконання яких залежить від розміру циклічної групи, такі як метод перебору, алгоритм бабочка-крок великий (baby-step giant-step) та метод Ро (Pollard’s rho). Другий клас — це алгоритми, час виконання яких залежить від розміру простих множників порядку групи, такі як алгоритм Погіля-Геллмана (Pohlig–Hellman).

\subsubsection{Метод перебору}

Метод перебору є найнаївнішим і найвитратнішим способом обчислення дискретного логарифму \( \log_\alpha \beta \). Ми просто послідовно обчислюємо степені генератора \( \alpha \), поки результат не дорівнюватиме \( \beta \):
\[
\begin{aligned}
\alpha^1 & = \alpha \\
\alpha^2 & = \alpha \cdot \alpha \\
& \vdots \\
\alpha^x & = \beta
\end{aligned}
\]
Для випадкового логарифму \( x \) ми очікуємо знайти правильне рішення після перевірки приблизно половини всіх можливих \( x \). Це дає нам складність \( O(|G|) \) кроків, де \( |G| \) — порядок групи.

Щоб уникнути атак методом перебору на криптосистеми, засновані на DLP, на практиці порядок \( |G| \) основної групи повинен бути достатньо великим. Наприклад, у випадку групи \( \mathbb{Z}^*_p \), яка є основою для DHKE, для обчислення дискретного логарифму вимагається приблизно \( \frac{p-1}{2} \) тестів в середньому. Таким чином, \( |G| = p - 1 \) має бути принаймні порядку \( 2^{80} \), щоб зробити перебір невиправданим з використанням сучасних комп'ютерних технологій. Звичайно, ця розглядка справедлива лише тоді, коли метод перебору є єдиною можливістю атаки, що ніколи не відповідає дійсності. Існують набагато потужніші алгоритми для вирішення DLP, про які ми розповімо нижче.

\subsubsection{Алгоритм бабочка-крок великий (Shanks’ Baby-Step Giant-Step Method)}

Алгоритм бабочка-крок великий — це метод компромісу між часом виконання і використанням пам'яті, який зменшує час перебору методом перебору за рахунок додаткового зберігання. Ідея базується на переписуванні дискретного логарифму \( x = \log_\alpha \beta \) у двохцифровому представленні:
\[
x = x_g m + x_b
\]
для \( 0 \leq x_g, x_b < m \),
де \( m \) обирається приблизно рівним квадратному кореню порядку групи, тобто \( m = \lceil \sqrt{|G|} \rceil \).

Ми можемо записати дискретний логарифм як
\[
\beta \cdot \alpha^{-m x_g} = \alpha^{x_b}.
\]
Ідея алгоритму полягає в тому, щоб знайти рішення \( (x_g, x_b) \), з якого дискретний логарифм слідує безпосередньо:
\[
x = x_g m + x_b.
\]
Алгоритм складається з двох фаз. У першій фазі (фаза бабочки) ми обчислюємо та зберігаємо всі значення \( \alpha^{x_b} \) для \( 0 \leq x_b < m \). Це вимагає \( m \approx \sqrt{|G|} \) кроків групових операцій і потребує зберігання \( m \approx \sqrt{|G|} \) групових елементів. У другій фазі (фаза кроку великого) алгоритм перевіряє для всіх \( x_g \) у межах \( 0 \leq x_g < m \), чи виконується умова:
\[
\beta \cdot \alpha^{-m x_g} = \alpha^{x_b}
\]
для деякого збереженого елемента \( \alpha^{x_b} \), обчисленого під час фази бабочки. У разі співпадіння, тобто \( \beta \cdot \alpha^{-m x_g} = \alpha^{x_b} \), дискретний логарифм визначається як
\[
x = x_g m + x_b.
\]
Метод бабочка-крок великий потребує \( O(\sqrt{|G|}) \) обчислювальних кроків і такої ж кількості пам'яті. У групі порядку \( 2^{80} \) зловмисник потребуватиме приблизно \( 2^{40} \) обчислень та місць для зберігання, що є досяжним з використанням сучасних ПК та жорстких дисків. Таким чином, щоб отримати складність атаки \( 2^{80} \), група повинна мати порядок принаймні \( |G| \geq 2^{160} \). У випадку груп \( \mathbb{Z}^*_p \), просте число \( p \) має мати довжину принаймні 160 біт. Проте, як ми побачимо нижче, існують потужніші атаки на DLP у \( \mathbb{Z}^*_p \), що вимагає ще більших бітових довжин \( p \).

\subsubsection{Метод Ро (Pollard’s Rho Method)}

Метод Ро має ту ж очікувану складність \( O(\sqrt{|G|}) \), що і алгоритм бабочка-крок великий, але з незначними вимогами до пам'яті. Цей метод є ймовірнісним алгоритмом, який базується на парадоксі дня народження. Основна ідея полягає в псевдовипадковій генерації групових елементів у формі \( \alpha^i \cdot \beta^j \). Для кожного елемента ми відстежуємо значення \( i \) та \( j \). Процес продовжується до тих пір, поки не буде знайдено колізію між двома елементами, тобто:
\[
\alpha^{i_1} \cdot \beta^{j_1} = \alpha^{i_2} \cdot \beta^{j_2}.
\]
Підставляючи \( \beta = \alpha^x \), порівнюємо показники обох сторін рівняння:
\[
i_1 + x j_1 \equiv i_2 + x j_2 \mod |G|.
\]
Звідси дискретний логарифм можна легко обчислити як:
\[
x \equiv \frac{i_2 - i_1}{j_1 - j_2} \mod |G|.
\]
Важливою деталлю, яку ми опускаємо тут, є точний спосіб знаходження колізії. Проте основна ідея полягає в тому, що псевдовипадкова генерація елементів здійснюється як випадкова прогулянка по групі. Саме тому метод отримав назву "rho", оскільки його траєкторія схожа на грецьку букву \(\rho\).

Метод Ро має велике практичне значення, оскільки він є найкращим відомим алгоритмом для обчислення дискретних логарифмів у групах, утворених еліптичними кривими. Оскільки метод має складність атаки \( O(\sqrt{|G|}) \), групи на основі еліптичних кривих повинні мати розмір принаймні \( 2^{160} \). Насправді, криптосистеми на основі еліптичних кривих з 160-бітовими операндами дуже популярні на практиці.

\subsubsection{Алгоритм Погіля-Геллмана (Pohlig–Hellman Algorithm)}

Алгоритм Погіля-Геллмана базується на китайській теоремі про залишки та використовує факторизацію порядку групи. Цей алгоритм зазвичай не використовується самостійно, а в поєднанні з іншими алгоритмами атаки на DLP, такими як метод Ро або алгоритм бабочка-крок великий. Нехай
\[
|G| = p_1^{e_1} \cdot p_2^{e_2} \cdot \ldots \cdot p_l^{e_l}
\]
є розкладанням порядку групи на прості множники. Ми також намагаємося обчислити дискретний логарифм \( x = \log_\alpha \beta \) у групі \( G \). Це також алгоритм розділяй і володарюй.

Основна ідея полягає в тому, щоб замість роботи з великою групою \( G \), обчислювати менші дискретні логарифми \( x_i \equiv x \mod p_i^{e_i} \) у підгрупах порядку \( p_i^{e_i} \). Бажаний дискретний логарифм \( x \) потім обчислюється з усіх \( x_i \) за допомогою китайської теореми про залишки. Кожен окремий малий DLP \( x_i \) може бути обчислений за допомогою методу Ро або алгоритму бабочка-крок великий.

Час виконання алгоритму очевидно залежить від простих множників порядку групи. Щоб запобігти атаці, порядок групи повинен мати найбільший простий множник принаймні \( 2^{160} \). Важливим практичним наслідком алгоритму Погіля-Геллмана є те, що необхідно знати факторизацію порядку групи. Особливо у випадку криптосистем на основі еліптичних кривих, обчислення порядку циклічної групи не завжди є простим.

\subsection{Негенеричні алгоритми: Метод індекс-калькюла}

Всі алгоритми, представлені до цього моменту, є повністю незалежними від групи, яку атакують, тобто вони працюють для дискретних логарифмів, визначених у будь-якій циклічній групі. Негенеричні алгоритми ефективно використовують спеціальні властивості, тобто внутрішню структуру, певних груп. Це може призвести до набагато потужніших алгоритмів для вирішення DLP. Найважливішим негенеричним алгоритмом є метод індекс-калькюла.

Як алгоритм бабочка-крок великий, так і метод Ро мають складність виконання, яка експоненціальна від бітової довжини порядку групи, а саме приблизно \( 2^{n/2} \) кроків, де \( n \) — бітова довжина \( |G| \). Це значно сприяє криптографічному дизайну перед криптоаналітиком. Наприклад, збільшення порядку групи на лише 20 бітів збільшує зусилля атаки в \( 2^{20} \approx 10^6 \) разів. Це є основною причиною, чому еліптичні криві мають кращу довгострокову безпеку порівняно з RSA або криптосистемами, заснованими на DLP у \( \mathbb{Z}^*_p \).

Питання полягає в тому, чи існують більш потужні алгоритми для DLP у певних специфічних групах. Відповідь — так.

Метод індекс-калькюла є дуже ефективним алгоритмом для обчислення дискретних логарифмів у циклічних групах \( \mathbb{Z}^*_p \) та \( \text{GF}(2^m)^* \). Він має субекспоненційну складність виконання. Ми не будемо вводити цей метод тут, а просто надамо дуже короткий опис. Метод індекс-калькюла залежить від властивості, що значна частина елементів групи \( G \) може бути ефективно виражена як добуток елементів з невеликої підмножини групи. Для групи \( \mathbb{Z}^*_p \) це означає, що багато елементів можна виразити як добуток малих простих чисел. Ця властивість задовольняється групами \( \mathbb{Z}^*_p \) та \( \text{GF}(2^m)^* \). Однак, поки що не знайдено спосіб зробити те саме для груп на основі еліптичних кривих. Метод індекс-калькюла настільки потужний, що для забезпечення безпеки рівня 80 біт, тобто для атаки зусиль рівня \( 2^{80} \), просте число \( p \) у \( \mathbb{Z}^*_p \) повинно мати довжину принаймні 1024 бітів. Таблиця \ref{tab:DLP_records} надає огляд досягнень у обчисленні дискретних логарифмів з початку 1990-х років. Метод індекс-калькюла є дещо потужнішим для вирішення DLP у \( \text{GF}(2^m)^* \). Отже, бітові довжини мають бути вибрані дещо довшими, щоб досягти того ж рівня безпеки. Через це схеми DLP у \( \text{GF}(2^m)^* \) не так широко використовуються на практиці.

\begin{table}[h!]
\centering
\begin{tabular}{|c|c|c|}
\hline
\textbf{Десяткові цифри} & \textbf{Бітова довжина} & \textbf{Дата} \\
\hline
58 & 193 & 1991 \\
\hline
65 & 216 & 1996 \\
\hline
85 & 282 & 1998 \\
\hline
100 & 332 & 1999 \\
\hline
120 & 399 & 2001 \\
\hline
135 & 448 & 2006 \\
\hline
160 & 532 & 2007 \\
\hline
\end{tabular}
\caption{Резюме записів для обчислення дискретних логарифмів у \( \mathbb{Z}^*_p \)}
\label{tab:DLP_records}
\end{table}

\subsection{Резюме атак на дискретний логарифм}

\begin{itemize}
    \item \textbf{Метод перебору}: Найпростіший метод з експоненціальною складністю \( O(|G|) \).
    \item \textbf{Алгоритм бабочка-крок великий}: Метод компромісу між часом та пам'яттю з складністю \( O(\sqrt{|G|}) \).
    \item \textbf{Метод Ро}: Ймовірнісний алгоритм з такою ж складністю, що і алгоритм бабочка-крок великий, але з меншими вимогами до пам'яті.
    \item \textbf{Алгоритм Погіля-Геллмана}: Алгоритм, який використовує факторизацію порядку групи для зменшення складності атаки.
    \item \textbf{Метод індекс-калькюла}: Найпотужніший алгоритм для \( \mathbb{Z}^*_p \) та \( \text{GF}(2^m)^* \) з субекспоненційною складністю.
\end{itemize}

\subsection{Висновки щодо безпеки DLP}

Загальна складність атак на DLP залежить від вибору групи та використовуваного алгоритму атаки. Для забезпечення високого рівня безпеки криптосистем, заснованих на дискретному логарифмі, необхідно використовувати групи з великим порядком та уникати груп, у яких існують ефективні негенеричні алгоритми атаки, такі як метод індекс-калькюла. Групи на основі еліптичних кривих пропонують кращу безпеку при менших розмірах ключів порівняно з класичними групами \( \mathbb{Z}^*_p \), що робить їх привабливими для використання у сучасних криптографічних протоколах.

\end{document}
