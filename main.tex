\documentclass[12pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[ukrainian]{babel}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{amsmath, amsfonts, amssymb}
\usepackage{amsthm}
\usepackage{fancyhdr}
\usepackage{cmap}
\usepackage{tikz}
\usepackage[a4paper, margin=2.5cm]{geometry}

% Налаштування стилю сторінок
\fancypagestyle{plain}{
  \fancyhf{}
  \fancyhead[L]{\thepage}
  \fancyhead[R]{Квас Кирил ПМп-43}
  \renewcommand{\headrulewidth}{1pt}
  \renewcommand{\footrulewidth}{0pt}
  \setlength{\headheight}{14.49998pt}
}

% Визначення стилів середовищ
\theoremstyle{definition}
\newtheorem{definition}{Визначення}[chapter]
\newtheorem{example}{Приклад}[chapter]

\theoremstyle{plain}
\newtheorem{theorem}{Теорема}[chapter]
\newtheorem{lemma}{Лема}[chapter]
\newtheorem{corollary}{Королярій}[chapter]

\setcounter{tocdepth}{2}

\begin{document}

% Титульна сторінка
\begin{titlepage}
    \begin{center}
        \large 
        \textbf{Міністерство освіти і науки України}\\
        \textbf{Львівський національний університет імені Івана Франка}\\
        \vspace{0.5cm}
        \textbf{Факультет прикладної математики та інформатики}\\
        \textbf{Кафедра прикладної математики}\\
        
        \vfill
        
        \Large 
        \textbf{Бакалаврська робота}\\
        \vspace{0.3cm}
        \normalsize 
        \textbf{на тему:}\\
        \vspace{0.3cm}
        \Large 
        \textbf{Ефективність класичних алгоритмів криптографії \\ на основі еліптичних кривих}\\
        
        \vfill
        
        \begin{flushright}
            \normalsize 
            Виконав студент групи ПМП-43:\\
            Квас Кирил Олегович\\
            спеціальність 113 — Прикладна математика\\
            \vspace{1cm}
            Науковий керівник:\\
            доцент, кандидат фізико-математичних наук\\
            Стягар Андрій Орестович \\
            \vspace{1cm}
            Рецензент:\\
            \vspace{0.5cm}
            \underline{\hspace{7cm}}
        \end{flushright}
        
        \vfill
        
        \normalsize 
        Львів — 2025
    \end{center}
\end{titlepage}

% Зміст
\tableofcontents

% Вступ
\chapter*{Вступ}
\addcontentsline{toc}{chapter}{Вступ}

У сучасному світі інформаційна безпека набуває все більшої значущості через постійне зростання обсягів переданої та збереженої інформації. Захист даних від несанкціонованого доступу, зміни чи видалення є ключовою задачею у сфері інформаційних технологій. Криптографія виступає основним інструментом для забезпечення конфіденційності, цілісності та автентичності інформації.

Криптографія має давню історію, починаючи ще з Стародавнього Єгипту, де використовувалися прості символічні шифри для передачі секретних повідомлень. У середньовіччі арабські вчені, такі як Аль-Хорезмі, зробили значний внесок у розвиток криптографії, створюючи складніші шифри та методи їх розшифровки.

У 20 столітті криптографія отримала новий імпульс завдяки появі комп'ютерів та сучасних методів математичного аналізу. Під час Другої світової війни розвиток криптографії досяг піку з розшифровкою німецьких шифрів «Енігма» Бертраном Расселом та іншими вченими. Ці події продемонстрували важливість криптографії для військових та державних потреб.

Після численних війн криптографія активно застосовується у цивільному секторі, особливо з розвитком електронної комунікації. Виникнення Інтернету та цифрових технологій підвищило потребу у надійних методах захисту інформації, що сприяло розвитку асиметричних криптографічних алгоритмів.

Метою цієї кваліфікаційної роботи є дослідження ефективності класичних алгоритмів криптографії на основі еліптичних кривих. Зокрема, буде проведено аналіз продуктивності певного класичного алгоритму та його варіації на основі еліптичних кривих, а також оцінено їх придатність для застосування у сучасних інформаційних системах.

Завданнями дослідження є:
\begin{itemize}
    \item Ознайомлення з основними принципами та теорією криптографії, необхідними для даної кваліфікаційної роботи.
    \item Аналіз існуючих класичних криптографічних алгоритмів та їх варіацій, що використовують еліптичні криві.
    \item Проведення експериментального дослідження ефективності обраних алгоритмів.
    \item Порівняння отриманих результатів та формулювання висновків щодо їх практичної застосовності.
\end{itemize}

\chapter{Постановка задачі}

\section{Описова постановка}

Нам задано класичний алгоритм асиметричної криптографії та його варіацію на основі еліптичних кривих. Метою дослідження є аналіз та пояснення процесу адаптації класичного алгоритму до версії на основі еліптичних кривих, а також оцінка їх ефективності, безпеки та практичної релевантності.

Зокрема, буде проведено порівняння обраного класичного алгоритму (Алгоритм 1) з його еквівалентною варіацією на основі еліптичних кривих (Алгоритм 2). Аналіз охоплюватиме наступні аспекти:
\begin{itemize}
    \item \textbf{Процес адаптації:} Вивчення змін у математичній основі та алгоритмічній структурі при переході від Алгоритму 1 до Алгоритму 2.
    \item \textbf{Ефективність:} Оцінка швидкості виконання операцій шифрування та дешифрування, використання обчислювальних ресурсів та розміру ключів.
    \item \textbf{Безпека:} Аналіз стійкості алгоритмів до сучасних криптографічних атак, включаючи класичні та квантові атаки.
    \item \textbf{Практична релевантність:} Визначення придатності алгоритмів для застосування у різних умовах, таких як мобільні пристрої, вбудовані системи та великі інформаційні мережі.
\end{itemize}

Дослідження спрямоване на визначення переваг та недоліків класичних асиметричних алгоритмів у порівнянні з їх варіаціями на основі еліптичних кривих, а також надання рекомендацій щодо вибору оптимальних криптографічних методів для різних сфер застосування.

\section{Математична модель}

Рисунки \ref{fig:basic_protocol_classical} та \ref{fig:basic_protocol_ecc} демонструють процес обміну зашифрованими повідомленнями між двома сторонами: відправником (Алісою) та отримувачем (Бобом) для класичного алгоритму та його еквіваленту на основі ECC відповідно.

\begin{figure}[htbp]
\begin{center}
\begin{tikzpicture}

% Alice and Bob nodes
\node at (-2, 0) {\textbf{Аліса}};
\node at (8, 0) {\textbf{Боб}};

% Encryption and decryption
\node at (-0.9, -1) {$y = e_{k_{\text{pub}}^{(1)}}(x)$};
\node at (6.9, -1) {$x = d_{k_{\text{pr}}^{(1)}}(y)$};

% Key pair generation
\node at (7.5, 1) {$(k_{\text{pub}}^{(1)}, k_{\text{pr}}^{(1)}) = k^{(1)}$};

% Arrows and labels
\draw[<-] (0.5, 1) -- (5.5, 1) node[midway, above] {$k_{\text{pub}}^{(1)}$};
\draw[->] (0.5, -1) -- (5.5, -1) node[midway, below] {$y^{(1)}$};

\end{tikzpicture}
\caption{Базовий протокол асиметричного шифрування на основі класичного алгоритму.}
\label{fig:basic_protocol_classical}
\end{center}
\end{figure}

\begin{figure}[htbp]
\begin{center}
\begin{tikzpicture}

% Alice and Bob nodes
\node at (-2, 0) {\textbf{Аліса}};
\node at (8, 0) {\textbf{Боб}};

% Encryption and decryption
\node at (-0.9, -1) {$y = e_{k_{\text{pub}}^{(2)}}(x)$};
\node at (6.9, -1) {$x = d_{k_{\text{pr}}^{(2)}}(y)$};

% Key pair generation
\node at (7.5, 1) {$(k_{\text{pub}}^{(2)}, k_{\text{pr}}^{(2)}) = k^{(2)}$};

% Arrows and labels
\draw[<-] (0.5, 1) -- (5.5, 1) node[midway, above] {$k_{\text{pub}}^{(2)}$};
\draw[->] (0.5, -1) -- (5.5, -1) node[midway, below] {$y^{(2)}$};

\end{tikzpicture}
\caption{Базовий протокол асиметричного шифрування на основі ECC.}
\label{fig:basic_protocol_ecc}
\end{center}
\end{figure}

\begin{itemize}
    \item \( k_{\text{pub}}^{(1)} \), \( k_{\text{pub}}^{(2)} \): публічний ключ для класичного алгоритму та ECC відповідно.
    \item \( k_{\text{pr}}^{(1)} \), \( k_{\text{pr}}^{(2)} \): приватний ключ для класичного алгоритму та ECC відповідно.
    \item \( k^{(1)} \), \( k^{(2)} \): пара ключів (публічний і приватний) для класичного алгоритму та ECC відповідно.
    \item \( e_{k_{\text{pub}}^{(1)}} \), \( e_{k_{\text{pub}}^{(2)}} \): функція шифрування з використанням публічного ключа.
    \item \( d_{k_{\text{pr}}^{(1)}} \), \( d_{k_{\text{pr}}^{(2)}} \): функція дешифрування з використанням приватного ключа.
    \item \( x \): вихідне повідомлення, яке потрібно зашифрувати.
    \item \( y^{(1)}, y^{(2)} \): зашифроване повідомлення з використанням класичного алгоритму та ECC відповідно.
\end{itemize}

\chapter{Проблема дискретного логарифму}

\section{Огляд головних криптографічних схем}

Сучасна криптографія спирається на три основні сімейства алгоритмів відкритого ключа, які мають практичну значущість і базуються на різних математичних проблемах. Кожне з цих сімейств забезпечує основні криптографічні функції, такі як встановлення ключів, цифрові підписи для нерепудійованості та шифрування даних. Нижче наведено короткий огляд цих трьох сімейств.

\subsection{Схеми на основі факторизації цілих чисел}

Схеми цього сімейства ґрунтуються на складності задачі факторизації великих цілих чисел. Найвідомішим представником є алгоритм RSA, запропонований у 1977 році. RSA широко використовується для шифрування, цифрових підписів та встановлення ключів. Ефективність RSA залежить від обчислювальної складності розкладу великих чисел на прості множники. При виборі належних параметрів, таких як довжина ключа, алгоритм забезпечує високий рівень безпеки.

\subsection{Схеми на основі дискретного логарифму}

Алгоритми цього сімейства базуються на задачі дискретного логарифму в скінченних полях. До найвідоміших представників належать:
\begin{itemize}
    \item Протокол обміну ключами Діффі–Геллмана (DHKE),
    \item Шифрування Ель-Гамаля (ElGamal Encryption),
    \item Алгоритм цифрового підпису (Digital Signature Algorithm, DSA).
\end{itemize}

Ці алгоритми були запропоновані в середині 1970-х років і залишаються надійними за умови правильного вибору параметрів. В основі їх безпеки лежить складність обчислення дискретного логарифму — задачі, для якої не існує відомих ефективних алгоритмів розв’язання.

\subsection{Схеми на основі еліптичних кривих}

Ця група є узагальненням схем на основі дискретного логарифму. Алгоритми на основі еліптичних кривих (Elliptic Curve Cryptography, ECC) були запропоновані в середині 1980-х років і мають перевагу у зменшенні розмірів ключів без втрати рівня безпеки. Найвідоміші приклади включають:
\begin{itemize}
    \item Обмін ключами за допомогою еліптичних кривих (Elliptic Curve Diffie–Hellman, ECDH),
    \item Алгоритм цифрового підпису на основі еліптичних кривих (Elliptic Curve Digital Signature Algorithm, ECDSA).
\end{itemize}

Схеми ECC використовують коротші ключі порівняно з класичними алгоритмами, такими як RSA, забезпечуючи той самий рівень криптографічної безпеки. Це робить ECC привабливими для середовищ з обмеженими ресурсами, наприклад, мобільних пристроїв або вбудованих систем.

\subsection{Інші схеми відкритого ключа}

Окрім трьох основних сімейств, існують також інші схеми, такі як:
\begin{itemize}
    \item Мультиваріативні квадратичні схеми (Multivariate Quadratic, MQ),
    \item Схеми на основі ґраток (Lattice-based schemes),
    \item Криптосистеми McEliece.
\end{itemize}

Проте ці схеми часто мають недостатню криптографічну зрілість або погані характеристики реалізації, такі як надмірно великі ключі. Інші схеми, наприклад, криптосистеми на основі гіпереліптичних кривих, є ефективними та безпечними, але поки що не набули широкого розповсюдження. Для більшості застосувань рекомендовано використовувати схеми з трьох основних сімейств.

\section{Алгебраїчні структури в контексті дискретного логарифму}

Для розуміння задачі дискретного логарифму важливо ввести базові алгебраїчні структури, які використовуються в криптографії. До них належать групи, циклічні групи та їхні підгрупи.

\subsection{Групи}

\begin{definition}[Група]
Групою \( G \) називається множина елементів разом з операцією \( \circ \), яка комбінує два елементи \( G \). Група задовольняє наступні властивості:
\begin{enumerate}
    \item \textbf{Замкненість:} Для всіх \( a, b \in G \) результат операції \( a \circ b \) також належить \( G \).
    \item \textbf{Асоціативність:} \( a \circ (b \circ c) = (a \circ b) \circ c \) для всіх \( a, b, c \in G \).
    \item \textbf{Нейтральний елемент:} Існує елемент \( e \in G \), такий що \( a \circ e = e \circ a = a \) для всіх \( a \in G \).
    \item \textbf{Обернений елемент:} Для кожного \( a \in G \) існує \( a^{-1} \in G \), такий що \( a \circ a^{-1} = a^{-1} \circ a = e \).
\end{enumerate}
Якщо додатково виконується \textbf{комутативність} (\( a \circ b = b \circ a \)), така група називається \textbf{абелевою}.
\end{definition}

\begin{example}
\begin{itemize}
    \item Множина цілих чисел \( \mathbb{Z} \) з операцією додавання утворює абелеву групу, де \( 0 \) є нейтральним елементом, а \( -a \) є оберненим до \( a \).
    \item Множина \( \mathbb{Z}^*_n \) (всі числа, менші за \( n \) та взаємно прості з \( n \)) з операцією множення за модулем \( n \) утворює абелеву групу, якщо \( n > 1 \).
\end{itemize}
\end{example}

\subsection{Скінченні групи}

\begin{definition}[Скінченна група]
Група \( (G, \circ) \) називається \textbf{скінченною}, якщо вона містить скінченну кількість елементів. Кількість елементів у групі називається її \textbf{порядком} і позначається \( |G| \).
\end{definition}

\begin{example}
\begin{itemize}
    \item Множина \( \mathbb{Z}_n \) з операцією додавання за модулем \( n \) має порядок \( |G| = n \).
    \item Для множини \( \mathbb{Z}^*_9 = \{1, 2, 4, 5, 7, 8\} \) порядок дорівнює \( |\mathbb{Z}^*_9| = 6 \).
\end{itemize}
\end{example}

\subsection{Циклічні групи}

\begin{definition}[Порядок елемента]
Порядком \( \text{ord}(a) \) елемента \( a \) групи \( (G, \circ) \) називається найменше додатне ціле число \( k \), таке що \( a^k = e \), де \( e \) — нейтральний елемент групи.
\end{definition}

\begin{example}
Визначимо порядок елемента \( a = 3 \) у групі \( \mathbb{Z}^*_{11} \):
\[
\begin{aligned}
a^1 & = 3 \\
a^2 & = 9 \mod 11 \\
a^3 & = 5 \mod 11 \\
a^4 & = 4 \mod 11 \\
a^5 & = 1 \mod 11
\end{aligned}
\]
Отже, \( \text{ord}(3) = 5 \).
\end{example}

\begin{definition}[Циклічна група]
Група \( G \) називається \textbf{циклічною}, якщо існує елемент \( \alpha \in G \) з порядком \( \text{ord}(\alpha) = |G| \). Такий елемент \( \alpha \) називається \textbf{генератором} або \textbf{примітивним елементом}, оскільки кожен елемент \( g \in G \) можна записати як \( g = \alpha^k \) для деякого \( k \).
\end{definition}

\begin{example}
Група \( \mathbb{Z}^*_{11} = \{1, 2, 3, 4, 5, 6, 7, 8, 9, 10\} \) є циклічною. Елемент \( 2 \) є генератором, оскільки степені \( 2^i \mod 11 \) проходять усі елементи групи:
\[
\{2, 4, 8, 5, 10, 9, 7, 3, 6, 1\}
\]
Отже, \( \text{ord}(2) = 10 = |\mathbb{Z}^*_{11}| \).
\end{example}

\subsection{Теореми про циклічні групи}

\begin{theorem}
Якщо \( |G| = n \), то порядок будь-якого елемента \( a \in G \) ділить \( n \).
\end{theorem}

\begin{theorem}
Якщо \( G \) є циклічною групою з порядком \( n \), то кількість генераторів у \( G \) дорівнює \( \varphi(n) \), де \( \varphi \) — функція Ейлера.
\end{theorem}

\begin{example}
Для групи \( \mathbb{Z}^*_{11} \) з порядком \( |G| = 10 \) кількість генераторів дорівнює \( \varphi(10) = 4 \). Ці генератори — елементи \( \{2, 6, 7, 8\} \).
\end{example}

\subsection{Підгрупи}

\begin{definition}[Підгрупа]
Підгрупою \( H \subset G \) називається підмножина \( H \), яка сама є групою щодо операції \( \circ \), визначеної в \( G \).
\end{definition}

\begin{theorem}[Циклічна підгрупа]
Нехай \( G \) є циклічною групою. Тоді кожен елемент \( a \in G \) з порядком \( \text{ord}(a) = s \) є генератором циклічної підгрупи з \( s \) елементами.
\end{theorem}

\begin{example}
Розглянемо групу \( \mathbb{Z}^*_{11} \). Елемент \( a = 3 \) має порядок \( \text{ord}(3) = 5 \), тому підгрупа, згенерована \( 3 \), містить елементи \( \{1, 3, 4, 5, 9\} \). Перевіримо це за допомогою таблиці множення:

\begin{table}[h!]
\centering
\begin{tabular}{c|ccccc}
\hline
$\times \mod 11$ & 1 & 3 & 4 & 5 & 9 \\
\hline
1 & 1 & 3 & 4 & 5 & 9 \\
3 & 3 & 9 & 1 & 4 & 5 \\
4 & 4 & 1 & 5 & 9 & 3 \\
5 & 5 & 4 & 9 & 3 & 1 \\
9 & 9 & 5 & 3 & 1 & 4 \\
\hline
\end{tabular}
\caption{Таблиця множення для підгрупи \( H = \{1, 3, 4, 5, 9\} \) у групі \( \mathbb{Z}^*_{11} \).}
\label{tab:multiplication_H}
\end{table}

Отже, \( H = \{1, 3, 4, 5, 9\} \) є підгрупою порядку \( 5 \).
\end{example}

\subsection{Теорема Лагранжа}

\begin{theorem}[Теорема Лагранжа]
Нехай \( H \) є підгрупою групи \( G \). Тоді порядок підгрупи \( |H| \) ділить порядок групи \( |G| \).
\end{theorem}

\begin{example}
Група \( \mathbb{Z}^*_{11} \) має порядок \( |G| = 10 \). Відповідно до теореми Лагранжа, можливі порядки підгруп: \( 1, 2, 5, 10 \). Підгрупи мають відповідні порядки:
\begin{itemize}
    \item \( H_1 = \{1\} \) з порядком \( 1 \),
    \item \( H_2 = \{1, 10\} \) з порядком \( 2 \),
    \item \( H_3 = \{1, 3, 4, 5, 9\} \) з порядком \( 5 \),
    \item \( H_4 = \mathbb{Z}^*_{11} \) з порядком \( 10 \).
\end{itemize}
\end{example}

\subsection{Циклічна підгрупа та Генератори}

\begin{theorem}
Нехай \( G \) є циклічною групою порядку \( n \), і нехай \( \alpha \) — її генератор. Тоді для кожного дільника \( k \) числа \( n \) існує рівно одна циклічна підгрупа \( H \) порядку \( k \), яка генерується елементом \( \beta = \alpha^{n/k} \). Підгрупа \( H \) складається з елементів \( \{1, \beta, \beta^2, \ldots, \beta^{k-1}\} \).
\end{theorem}

\begin{example}
Розглянемо групу \( \mathbb{Z}^*_{11} \) з порядком \( |G| = 10 \) і генератором \( \alpha = 8 \). Хочемо знайти генератор підгрупи порядку \( k = 2 \):
\[
\beta = \alpha^{10/2} = 8^5 \equiv 32768 \equiv 10 \mod 11.
\]
Перевіримо, що \( \beta = 10 \) генерує підгрупу \( H = \{1, 10\} \):
\[
\beta^1 \equiv 10 \mod 11, \quad \beta^2 \equiv 100 \equiv 1 \mod 11.
\]
Отже, \( H = \{1, 10\} \) є підгрупою порядку \( 2 \), згенерованою елементом \( 10 \).
\end{example}

\section{Дискретний логарифм}

\subsection{Формальне визначення дискретного логарифму}

Дискретний логарифм у групі \( \mathbb{Z}^*_p \), де \( p \) — просте число, є однією з ключових складових багатьох криптографічних протоколів. Його складність забезпечує безпеку криптосистем.

\begin{definition}[Дискретний логарифм (DLP) в \( \mathbb{Z}^*_p \)]
Дано скінченну циклічну групу \( \mathbb{Z}^*_p \) порядку \( p - 1 \), примітивний елемент \( \alpha \in \mathbb{Z}^*_p \) та інший елемент \( \beta \in \mathbb{Z}^*_p \). DLP полягає у визначенні цілого числа \( 1 \leq x \leq p - 1 \), такого що:
\[
\alpha^x \equiv \beta \mod p
\]
Таке число \( x \) називається дискретним логарифмом \( \beta \) до основи \( \alpha \) і записується як:
\[
x = \log_\alpha \beta \mod p.
\]
Обчислення дискретних логарифмів за модулем простого числа є дуже складною задачею за умови достатньо великих параметрів. Оскільки експонентування \( \alpha^x \equiv \beta \mod p \) є обчислювально легким, це утворює односторонню функцію.
\end{definition}

\subsection{Приклади дискретного логарифму}

\begin{example}
Розглянемо дискретний логарифм у групі \( \mathbb{Z}^*_{47} \), де \( \alpha = 5 \) є примітивним елементом. Для \( \beta = 41 \) задача дискретного логарифму полягає у визначенні позитивного цілого числа \( x \), такого що
\[
5^x \equiv 41 \mod 47
\]
Використовуючи метод перебору, ми отримуємо розв'язок \( x = 15 \).
\end{example}

\subsection{Узагальнений дискретний логарифм (GDLP)}

\begin{definition}[Узагальнений дискретний логарифм (GDLP)]
Дано скінченну циклічну групу \( G \) з операцією групи \( \circ \) та порядком \( n \). Розглядається примітивний елемент \( \alpha \in G \) та інший елемент \( \beta \in G \). Задача дискретного логарифму полягає у визначенні цілого числа \( x \), де \( 1 \leq x \leq n \), такого що:
\[
\beta = \alpha \circ \alpha \circ \ldots \circ \alpha = \alpha^x
\]
(повторення \( \alpha \) \( x \) разів).
\end{definition}

Як і у випадку DLP у \( \mathbb{Z}^*_p \), таке число \( x \) обов'язково існує, оскільки \( \alpha \) є примітивним елементом, і таким чином кожен елемент групи \( G \) можна згенерувати шляхом повторного застосування операції групи до \( \alpha \).

\subsection{Приклад узагальненого дискретного логарифму}

\begin{example}[Приклад 8.13]
Розглянемо адитивну групу цілих чисел за модулем простого числа. Нехай \( p = 11 \), група \( G = (\mathbb{Z}_{11}, +) \) є скінченною циклічною групою з примітивним елементом \( \alpha = 2 \). Ось як \( \alpha \) генерує групу:
\[
\begin{array}{c|ccccccccccc}
i & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 \\
\hline
i\alpha & 2 & 4 & 6 & 8 & 10 & 1 & 3 & 5 & 7 & 9 & 0 \\
\end{array}
\]
Спробуємо вирішити DLP для елемента \( \beta = 3 \), тобто знайти \( x \), таке що
\[
x \cdot 2 \equiv 3 \mod 11
\]
Щоб знайти \( x \), інвертуємо \( 2 \) за модулем 11:
\[
x \equiv 2^{-1} \cdot 3 \mod 11
\]
За допомогою розширеного алгоритму Евкліда, \( 2^{-1} \equiv 6 \mod 11 \), отже:
\[
x \equiv 6 \cdot 3 \equiv 18 \equiv 7 \mod 11
\]
Перевіримо:
\[
7 \cdot 2 = 14 \equiv 3 \mod 11
\]
Отже, \( x = 7 \).
\end{example}

Ми можемо узагальнити цей метод до будь-якої групи \( (\mathbb{Z}_n, +) \) для довільного \( n \) та елементів \( \alpha, \beta \in \mathbb{Z}_n \). Таким чином, узагальнений DLP є обчислювально легким у \( \mathbb{Z}_n \), оскільки використовуються прості математичні операції, такі як множення та інверсія.

\section{Безпека дискретного логарифму}

У цьому розділі розглядаються основні методи атаки на задачу дискретного логарифму (DLP). Безпека багатьох асиметричних криптосистем базується на складності обчислення DLP у циклічних групах, тобто на визначенні \( x \) для даних \( \alpha \) та \( \beta \) у групі \( G \), таких що
\[
\beta = \alpha^x
\]
(повторення \( \alpha \) \( x \) разів).

Складність вирішення DLP залежить від обраної групи та використовуваних алгоритмів атаки. Наразі не існує відомих алгоритмів, що вирішують DLP за поліноміальний час у загальному випадку, що робить цю задачу основою для безпеки багатьох криптографічних протоколів.

\begin{itemize}
    \item \textbf{Алгоритми, залежні від розміру групи}:
    \begin{itemize}
        \item \textbf{Метод перебору}: Найпростіший та найвитратніший метод з експоненціальною складністю \( O(|G|) \). Він полягає в послідовному обчисленні степенів генератора \( \alpha \) до тих пір, поки не буде знайдено \( x \), таке що \( \alpha^x = \beta \).
        
        \item \textbf{Метод малий крок – великий крок (baby-step giant-step)}: Алгоритм з складністю \( O(\sqrt{|G|}) \), який використовує компроміс між часом виконання та використанням пам'яті. Він розділяє дискретний логарифм на дві частини та використовує таблиці для швидкого пошуку відповідей.
        
        \item \textbf{Метод Ро Полларда (Pollard’s Rho)}: Ймовірнісний алгоритм також зі складністю \( O(\sqrt{|G|}) \), але з меншими вимогами до пам'яті. Він використовує псевдовипадкову генерацію елементів групи та виявляє колізії для знаходження дискретного логарифму.
    \end{itemize}
    
    \item \textbf{Алгоритми, залежні від розміру простих множників порядку групи}:
    \begin{itemize}
        \item \textbf{Алгоритм Поліґа-Геллмана (Pohlig–Hellman)}: Використовує факторизацію порядку групи для розбиття задачі DLP на менші підзадачі в підгрупах з простими порядками. Це дозволяє значно зменшити обчислювальну складність, особливо коли порядок групи має малий найбільший простий дільник.
    \end{itemize}
\end{itemize}

\begin{itemize}
    \item \textbf{Метод Index Calculus}: Найпотужніший алгоритм для груп \( \mathbb{Z}^*_p \) та \( \text{GF}(2^m)^* \) з субекспоненціальною складністю. Він базується на факторизації елементів групи через малу підмножину базових елементів, що дозволяє ефективно обчислювати дискретні логарифми. Проте цей метод не застосовується до груп на основі еліптичних кривих, що робить ECC більш безпечним вибором у цьому контексті.
\end{itemize}

\chapter{Шифрування Ель-Гамаля (ElGamal)}

\section{Основна ідея протоколу}

Протокол Ель-Гамаля (ElGamal) — це одна з криптосистем відкритого ключа, яка забезпечує конфіденційність повідомлень на основі складності розв’язання задачі дискретного логарифму. Алгоритм був запропонований Тахером Ель-Гамалем у 1985 році й ґрунтується на протоколі обміну ключами Діффі–Геллмана.

\textbf{Основні фази алгоритму Ель-Гамаля}: 
\begin{itemize}
    \item \textbf{Генерація ключів (Set-up):} виконується отримувачем (Бобом), який бажає отримувати зашифровані повідомлення.
    \item \textbf{Шифрування (Encryption):} виконується відправником (Алісою) для кожного повідомлення.
    \item \textbf{Розшифрування (Decryption):} виконується Бобом для кожного отриманого шифротексту.
\end{itemize}

\section{Формальний опис схеми}

Нехай \(p\) — велике просте число, а \(\alpha\) — примітивний елемент (генератор) у групі \(\mathbb{Z}_p^*\) або (що часто зустрічається на практиці) у деякій підгрупі простого порядку цієї групи. Для унаочнення припустимо, що всі дії відбуваються за модулем \(p\).

\subsection{Генерація ключів}

\begin{itemize}
    \item \textbf{Крок 1.} Боб обирає велике просте число \(p\). (Зазвичай \(p\) має довжину щонайменше 1024 біти.)
    \item \textbf{Крок 2.} Боб обирає примітивний елемент (генератор) \(\alpha \in \mathbb{Z}_p^*\). Як правило, \(\alpha\) генерує велику підгрупу простого порядку, щоб уникнути атак на малі підгрупи.
    \item \textbf{Крок 3.} Боб випадково обирає секретне число \(d \in \{2, 3, \dots, p - 2\}\). Це його приватний ключ.
    \item \textbf{Крок 4.} Боб обчислює відкритий ключ \(\beta = \alpha^d \bmod p\).
    \item \textbf{Крок 5.} Боб публікує свій відкритий ключ \(\bigl(p, \alpha, \beta\bigr)\) у відкритому реєстрі або на своєму веб-сайті, а приватний ключ \(d\) зберігає у таємниці.
\end{itemize}

Таким чином, \(\text{Bob}:\ (k_{\text{pub}}, k_{\text{pr}}) = \bigl(\{p, \alpha, \beta\}, d\bigr)\).

\subsection{Шифрування}

Припустімо, що Аліса хоче надіслати Бобу повідомлення \(x\), де \(x\) належить \(\mathbb{Z}_p^*\). Процес шифрування виглядає так:

\begin{itemize}
    \item \textbf{Крок 1.} Аліса отримує публічний ключ Боба \(\bigl(p, \alpha, \beta\bigr)\) (наприклад, з відкритої бази ключів).
    \item \textbf{Крок 2.} Аліса випадково обирає тимчасовий (``ефемерний'') показник \(i \in \{2, 3, \dots, p - 2\}\).
    \item \textbf{Крок 3.} Обчислює \(\displaystyle k_E = \alpha^i \bmod p\). Це так званий \textit{ефемерний ключ}, який передаватиметься у відкритому вигляді.
    \item \textbf{Крок 4.} Обчислює \(\displaystyle k_M = \beta^i \bmod p\). Це \textit{маскуючий ключ}, за допомогою якого «приховують» вихідний текст.
    \item \textbf{Крок 5.} Шифротекст формується у два елементи:
          \[
              y = x \cdot k_M \bmod p
          \]
          і пара \(\bigl(k_E,\, y\bigr)\).
    \item \textbf{Крок 6.} Аліса надсилає Бобу пару \(\bigl(k_E, y\bigr)\).
\end{itemize}

\subsection{Розшифрування}

Отримавши пару \(\bigl(k_E, y\bigr)\), Боб може легко відновити повідомлення \(x\), маючи свій приватний ключ \(d\). Для цього він виконує:

\begin{itemize}
    \item \textbf{Крок 1.} Обчислює 
          \(\displaystyle k_M = \bigl(k_E\bigr)^d \bmod p\).
    \item \textbf{Крок 2.} Знаходить обернений елемент до \(k_M\) за модулем \(p\). Можна обчислити \(k_M^{-1} \bmod p\) за допомогою розширеного алгоритму Евкліда або скористатись малою теоремою Ферма:
          \[
             k_M^{-1} \equiv k_M^{\,p-2} \bmod p 
          \]
          (якщо \(k_M\) не дорівнює нулю за модулем \(p\), тобто належить \(\mathbb{Z}_p^*\)).
    \item \textbf{Крок 3.} Відновлює текст:
          \[
             x = y \cdot k_M^{-1} \bmod p.
          \]
\end{itemize}

Таким чином, маючи \(d\), Боб легко вираховує оригінальне \(x\).

\subsection{Коректність}

Переконаємося, що описані вище кроки дійсно відтворюють вихідне повідомлення:
\[
\begin{aligned}
x &\equiv y \cdot k_M^{-1} \bmod p \\
  &\equiv \bigl(x \cdot \beta^i\bigr) \cdot \bigl(\bigl(\alpha^i\bigr)^d\bigr)^{-1} \bmod p \\
  &\equiv x \cdot \alpha^{\,d\cdot i} \cdot \alpha^{-\,d\cdot i} \bmod p \\
  &\equiv x \bmod p.
\end{aligned}
\]

\section{Приклад}

Для ілюстрації розглянемо малий числовий приклад (нерекомендований для реальних застосувань через надто малий модуль):

\begin{example}
\textbf{Нехай} \(p = 29\), \(\alpha = 2\). Боб обирає \(d = 12\) та обчислює \(\beta = \alpha^d = 2^{12} \bmod 29 \equiv 7\). Отже, відкритий ключ Боба: \((p, \alpha, \beta) = (29, 2, 7)\), а приватний ключ \(d = 12\).

\textbf{Шифрування.} Аліса хоче зашифрувати повідомлення \(x = 26\).
\begin{itemize}
    \item Випадково обирає \(i = 5\).
    \item Обчислює \(k_E = \alpha^i = 2^5 \bmod 29 \equiv 3\).
    \item Обчислює \(k_M = \beta^i = 7^5 \bmod 29 \equiv 16\).
    \item Обчислює \(y = x \cdot k_M \bmod 29 = 26 \cdot 16 \bmod 29 \equiv 10\).
    \item Надсилає Бобу пару \(\bigl(k_E, y\bigr) = (3, 10)\).
\end{itemize}

\textbf{Розшифрування.} Боб отримує \((k_E, y) = (3, 10)\).
\begin{itemize}
    \item Обчислює \(k_M = (k_E)^d \bmod 29 = 3^{12} \bmod 29 \equiv 16\).
    \item Знаходить \(k_M^{-1}\) (наприклад, \(16 \cdot 20 \equiv 1 \bmod 29\)), тобто \(k_M^{-1} = 20\).
    \item Відновлює \(x = 10 \cdot 20 \bmod 29 \equiv 26\).
\end{itemize}

Таким чином, \(26\) успішно відновлено.
\end{example}

\section{Безпека алгоритму Ель-Гамаля}

Безпека Ель-Гамаля базується на складності задачі дискретного логарифму (DLP) та спорідненої з нею задачі Діффі–Геллмана (DHP). Основні можливі атаки:

\begin{itemize}
    \item \textbf{Пасивна атака (прослуховування).} Супротивник, який перехоплює повідомлення, бачить лише \(p, \alpha, \beta\), ефемерний ключ \(k_E\) і шифротекст \(y\). Йому доведеться розв’язувати DLP, щоб знайти або приватний ключ \(d\) (через \(\beta = \alpha^d\)), або випадкову величину \(i\) (через \(k_E = \alpha^i\)).
    \item \textbf{Атака з активною участю (man-in-the-middle).} Як і в багатьох протоколах з відкритими ключами, необхідно пересвідчитись, що саме ключ Боба використовується для шифрування. Для цього на практиці застосовують сертифікати та інфраструктуру відкритих ключів (PKI).
    \item \textbf{Повторне використання ефемерного показника \(i\).} Якщо випадковий показник \(i\) колись повториться, то для двох різних повідомлень \(x_1\) і \(x_2\) буде згенеровано однаковий маскуючий ключ \(k_M\), що робить криптосистему вразливою. Тому рекомендується ретельно стежити, щоб \(i\) не повторювався.
    \item \textbf{Атаки на невеликі підгрупи (small subgroup attack).} Для уникнення цієї проблеми часто обирають \(\alpha\), що генерує підгрупу простого порядку.
\end{itemize}

Важливо зазначити, що Ель-Гамаль є \textit{ймовірнісною} криптосистемою: навіть якщо Аліса двічі шифрує однакове повідомлення \(x\), з великою ймовірністю будуть отримані різні шифротексти завдяки рандомізації \(i\).

Алгоритм Ель-Гамаля ілюструє потужність та гнучкість криптосистем, побудованих на основі дискретного логарифму. Його надійність обумовлена складністю DLP і тим, що швидке обчислення дискретних логарифмів у загальному випадку лишається невідомим. Проте належний вибір параметрів, уникнення малих підгруп, використання надійних випадкових величин для «ефемерних» показників та перевірка автентичності публічного ключа є вирішальними для безпеки та практичної реалізації криптосистеми Ель-Гамаля.

\chapter{Введення в еліптичні криві}
\label{ch:elliptic_curves}

\section{Мотивація та базові означення}

У сучасній криптографії еліптичні криві (англ. \textit{Elliptic Curves}) займають особливе місце завдяки тому, що задача дискретного логарифму на еліптичних кривих (ECDLP) вважається складнішою порівняно з аналогічною задачею в класичних групах (наприклад, у \(\mathbb{Z}_p^*\)). Це дозволяє досягати високого рівня безпеки за відносно меншої довжини ключа, що є критично важливим для систем з обмеженими обчислювальними ресурсами.

\begin{definition}[Еліптична крива над простим полем]
Нехай \(p\) — велике просте число. \textit{Еліптичною кривою} над полем \(\mathbb{F}_p\) називають множину розв'язків рівняння
\[
   E: \quad y^2 \equiv x^3 + a x + b \mod p
\]
разом із спеціальною \textit{ненульовою} точкою \(\mathcal{O}\) (``точкою на нескінченності''), де \(a, b \in \mathbb{F}_p\) обираються таким чином, щоб \(\text{disc}(E) = 4 a^3 + 27 b^2 \not\equiv 0 \mod p\). Це забезпечує відсутність особливостей (singularities) на кривій.
\end{definition}

Кожна точка \(P \in E\) має координати \((x, y)\) у полі \(\mathbb{F}_p\). Разом із операцією додавання, яку визначено спеціальним чином, точки еліптичної кривої утворюють \textit{циклічну групу}. Нейтральним елементом в цій групі є точка \(\mathcal{O}\).

\section{Операції на еліптичних кривих}

\subsection{Додавання точок}
Нехай \(P, Q \in E\). Визначимо \(P + Q\) як «геометричну» операцію:
\begin{itemize}
    \item Якщо \(P \neq Q\), проводимо пряму, що з'єднує \(P\) і \(Q\). Ця пряма перетинає криву \(E\) ще в одній точці \(R\). Віддзеркаливши \(R\) відносно осі \(x\), отримаємо \(P+Q\).
    \item Якщо \(P = Q\) (подвоєння точки \(2P\)), замість прямої «через \(P\) і \(Q\)» розглядаємо дотичну в \(P\). Вона також перетинає \(E\) у деякій точці \(R\), після чого відбиваємо \(R\) відносно осі \(x\).
    \item Якщо одна з точок є \(\mathcal{O}\), то \(P + \mathcal{O} = P\).
\end{itemize}

У алгебраїчному вигляді (у полях \(\mathbb{F}_p\)) формули для \(P + Q\) отримуються через операції додавання, множення, інвертування \(\mod p\). Таким чином визначають \textbf{адитивну} групу точок кривої: \((E, +)\).

\subsection{Множення точки на скаляр (Point Multiplication)}

Операція \(dP\) (``скалярне множення'' або ``point multiplication'') означає додавання точки \(P\) із собою \(d\) разів:
\[
   dP = \underbrace{P + P + \ldots + P}_{d \text{ разів}}.
\]

Аналогією до \(\alpha^d\) у класичних схемах \(\mathbb{Z}_p^*\) є саме \(dP\) в групі точок \(E\). Обчислювати \(dP\) наївним додаванням \(d\) разів неефективно, тому застосовують алгоритм \textit{Double-and-Add (Подвоєння й Додавання)}, аналогічний до ``square-and-multiply'':

\begin{definition}[Double-and-Add алгоритм]
\textbf{Вхід:} Точка \(P \in E\), ціле \(d\) зі степеневим поданням \(d = \sum_{i=0}^{t} d_i 2^i\), де \(d_i \in \{0,1\}\).  
\textbf{Вихід:} \(T = dP.\)

\begin{enumerate}
    \item Покласти \(T = P\).
    \item Для \(i = t-1 \text{ до } 0\) виконати:
    \begin{enumerate}
        \item \(T \leftarrow T + T\) \quad (подвоєння)
        \item Якщо \(d_i = 1\), то \(T \leftarrow T + P\).
    \end{enumerate}
    \item Повернути \(T\).
\end{enumerate}
\end{definition}

Таким чином, для \(t\) бітів скаляра \(d\) алгоритм виконує приблизно \(1.5t\) операцій додавання/подвоєння точок.

\begin{example}
Нехай нам треба обчислити \(26P\). У двійковому поданні \(26 = (11010)_2\). Алгоритм переглядає біти числа зліва направо, кожного разу роблячи подвоєння, а якщо біт дорівнює \(1\) — ще й додавання \(P\).
\end{example}

\chapter{Перехід від класичного ElGamal до ElGamal на основі еліптичних кривих}
\label{ch:ec_elgamal}

\section{Загальна ідея}

Подібно до того, як алгоритм Ель-Гамаля (ElGamal) у класичному варіанті \(\mathbb{Z}_p^*\) спирається на складність дискретного логарифму, існує його версія для еліптичних кривих — EC ElGamal (Elliptic Curve ElGamal). Тут замість обчислення \(\alpha^d \mod p\) та \(\alpha^i \mod p\) використовують точки на еліптичній кривій та операцію \(dP\). Безпека базується на задачі \(\text{ECDLP}\) (Elliptic Curve Discrete Logarithm Problem).

\section{Алгоритм ElGamal на еліптичній кривій}

Нехай задано:
\begin{itemize}
    \item \((E, +)\) — еліптична крива над \(\mathbb{F}_p\),
    \item \(P\) — точка-генератор великого порядку \(n \approx p\).
\end{itemize}

Аналогія з класичним ElGamal виглядає так:

\subsection{Генерація ключів}
\begin{enumerate}
    \item \textbf{Приватний ключ:} \(d \in \{1,\ldots, n-1\}\).
    \item \textbf{Публічний ключ:} \(\beta = dP\).
    \item Усі параметри \((E, p, P, \beta)\) публікуються, а \(d\) зберігається у таємниці.
\end{enumerate}

\subsection{Шифрування}
Нехай повідомлення \(M\) закодоване як точка \(M \in E\) (існують різні методи «вкладення» бітових даних у точку кривої). Щоб зашифрувати \(M\), відправник:
\begin{enumerate}
    \item Випадково обирає ефемерний показник \(i \in \{1,\ldots, n-1\}\).
    \item Обчислює ефемерний ключ \(k_E = iP\).
    \item Обчислює маскуючий ключ \(k_M = i\beta = i(dP) = (id)P\).
    \item Формує шифротекст \(C = \bigl( k_E,\; M + k_M \bigr)\).
\end{enumerate}

\subsection{Розшифрування}
Одержувач, який знає свій приватний ключ \(d\), отримавши пару \((k_E, \; M + k_M)\):
\begin{enumerate}
    \item Обчислює \(d \cdot k_E = d(iP) = (di)P = k_M\).
    \item Відновлює повідомлення: \(M = (M + k_M) - k_M\).
\end{enumerate}

\section{Переваги та недоліки EC ElGamal}

\begin{itemize}
    \item \textbf{Переваги:}   
    \begin{itemize}
        \item Менший розмір ключів порівняно з класичними схемами на \(\mathbb{Z}_p^*\) (RSA, DSA/ElGamal тощо) при однаковому рівні безпеки.
        \item Вищий темп обчислень (шифрування/розшифрування) у середовищах з обмеженими ресурсами (смарт-картки, мобільні пристрої тощо).
        \item Стійкість до потужних методів індекс-числення, які ефективно застосовуються у звичайній групі \(\mathbb{Z}_p^*\).
    \end{itemize}

    \item \textbf{Недоліки:}  
    \begin{itemize}
        \item Складніша реалізація: необхідне ретельне тестування кривих, щоб уникнути «слабких сімейств».
        \item Складність (і нерідко патентні обмеження) у реалізації «вкладення» довільних бітових повідомлень у точки \(E\).
        \item Безпека суттєво залежить від вибору правильної кривої, її параметрів і порядку підгрупи.
    \end{itemize}
\end{itemize}

\chapter{Графічне представлення результатів}

У цьому розділі представлено графік, що ілюструє залежність часу шифрування (у мілісекундах) від розміру повідомлення (у мегабайтах) для класичного алгоритму ElGamal та його варіанту на основі еліптичних кривих (EC ElGamal). Графік створено за допомогою зовнішньої програми, а тут він вставлений як зображення.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=1.2\textwidth]{thesis/graph.png} 
  \caption{Залежність часу шифрування від розміру повідомлення для класичного ElGamal та EC ElGamal.}
  \label{fig:graph_photo_jpg}
\end{figure}

\noindent
Для вставки зображення використовується команда \verb|\includegraphics| з пакету \verb|graphicx|.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Розділ з висновками та список використаних джерел
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter*{Висновки}
\addcontentsline{toc}{chapter}{Висновки}

У даній роботі було проведено комплексний аналіз ефективності класичних алгоритмів криптографії та їх адаптації на основі еліптичних кривих. Розглянуто математичні основи криптографічних схем, зокрема задачі дискретного логарифму та її узагальнення для еліптичних кривих (ECDLP). Аналіз протоколів ElGamal та EC ElGamal дозволив зробити наступні висновки:

\begin{itemize}
    \item Адаптація класичного алгоритму ElGamal до еліптичних кривих дозволяє забезпечити еквівалентний рівень безпеки за значно меншого розміру ключа, що є критично важливим для сучасних систем з обмеженими обчислювальними ресурсами.
    \item Використання еліптичних кривих забезпечує вищу ефективність операцій шифрування та розшифрування, що було підтверджено експериментальними результатами, зображеними на графіку.
    \item Незважаючи на переваги, реалізація криптосистем на основі еліптичних кривих вимагає особливої уваги до вибору параметрів та ретельного тестування обраних кривих для уникнення потенційних вразливостей (наприклад, атак на малі підгрупи).
    \item Практична релевантність досліджуваних підходів підтверджується їх здатністю забезпечувати конфіденційність, цілісність та автентичність інформації, що робить їх перспективними для застосування у широкому спектрі сучасних інформаційних систем.
\end{itemize}

Отже, результати дослідження свідчать про доцільність впровадження еліптичних кривих у криптографічні схеми, що дозволяє оптимізувати використання ресурсів без компромісу щодо рівня безпеки.

\addcontentsline{toc}{chapter}{Список використаних джерел}

\begin{thebibliography}{9}
\bibitem{handbook} A. J. Menezes, P. C. van Oorschot, S. A. Vanstone, \textit{Handbook of Applied Cryptography}, CRC Press, 1996.
\bibitem{koblitz} N. Koblitz, \textit{Elliptic Curve Cryptosystems}, Mathematics of Computation, vol. 48, no. 177, pp. 203--209, 1987.
\bibitem{miller} V. S. Miller, \textit{Use of Elliptic Curves in Cryptography}, Advances in Cryptology — CRYPTO '85 Proceedings, pp. 417--426, 1986.
\bibitem{elgamal} T. ElGamal, \textit{A Public Key Cryptosystem and a Signature Scheme Based on Discrete Logarithms}, IEEE Transactions on Information Theory, vol. 31, no. 4, pp. 469--472, 1985.
\end{thebibliography}

\end{document}
